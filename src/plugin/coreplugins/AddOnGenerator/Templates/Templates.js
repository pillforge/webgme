//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "addOn.js.ejs": "/*globals define*/\r\n/*jshint node:true, browser:true*/\r\n\r\n/**\r\n * Generated by AddOnGenerator <%= version %> from webgme on <%= date %>.\r\n */\r\n\r\ndefine([\r\n    'addOn/AddOnBase'\r\n], function (AddOnBase) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Initializes a new instance of <%= addOnId %>.\r\n     * @class\r\n     * @augments {AddOnBase}\r\n     * @classdesc This class represents the addOn <%= addOnId %>.\r\n     * @constructor\r\n     */\r\n    var <%= addOnId %> = function (mainLogger, gmeConfig) {\r\n        // Call base class' constructor.\r\n        AddOnBase.call(this, mainLogger, gmeConfig);\r\n    };\r\n\r\n    // Prototypal inheritance from AddOnBase.\r\n    <%= addOnId %>.prototype = Object.create(AddOnBase.prototype);\r\n    <%= addOnId %>.prototype.constructor = <%= addOnId %>;\r\n\r\n    /**\r\n     * Gets the name of the <%= addOnId %>.\r\n     * @returns {string} The name of the AddOn.\r\n     * @public\r\n     */\r\n    <%= addOnId %>.prototype.getName = function () {\r\n        return '<%= addOnName %>';\r\n    };\r\n\r\n    /**\r\n     * Gets the semantic version (semver.org) of the <%= addOnId %>.\r\n     * @returns {string} The version of the AddOn.\r\n     * @public\r\n     */\r\n    <%= addOnId %>.prototype.getVersion = function () {\r\n        return '0.1.0';\r\n    };<% if (description) {%>\r\n\r\n    /**\r\n     * Gets the description of the <%= addOnId %>.\r\n     * @returns {string} The description of the AddOn.\r\n     * @public\r\n     */\r\n    <%= addOnId %>.prototype.getDescription = function () {\r\n        return '<%= description %>';\r\n    };<%}%>\r\n\r\n    /**\r\n     * This is invoked each time changes in the branch of the project are done. AddOns are allowed to make changes on\r\n     * an update, but should not persist by themselves. (The AddOnManager will persist after each addOn has had its way\r\n     * ordered by the usedAddOn registry in the rootNode).\r\n     * Before each invocation a new updateResult is created which should be returned in the callback. There is no need\r\n     * for the AddOn to report if it made changes or not, the monitor/manager will always persist and if there are no\r\n     * changed objects - it won't commit to the storage.\r\n     * @param {object} rootNode\r\n     * @param {object} commitObj\r\n     * @param {function(Error, AddOnUpdateResult)} callback\r\n     */\r\n    <%= addOnId %>.prototype.update = function (rootNode, commitObj, callback) {\r\n        var newName = commitObj.updater.toString();\r\n        this.logger.info('<%= addOnId %> in update at commitHash', commitObj._id);\r\n\r\n        if (this.core.getAttribute(rootNode, 'name') !== newName) {\r\n            this.logger.info('<%= addOnId %> changing name of root to committer(s): ', newName);\r\n            this.core.setAttribute(rootNode, 'name', newName);\r\n            this.addCommitMessage('Changed rootNode name to \"' + newName + '\"');\r\n        }\r\n\r\n        callback(null, this.updateResult);\r\n    };\r\n\r\n    /**\r\n     * Called once when the addOn is started for the first time.\r\n     * @param {object} rootNode\r\n     * @param {object} commitObj\r\n     * @param {function(Error, AddOnUpdateResult} callback\r\n     */\r\n    <%= addOnId %>.prototype.initialize = function (rootNode, commitObj, callback) {\r\n        this.logger.info('<%= addOnId %> got initialized at commitHash', commitObj._id);\r\n\r\n        this.update(rootNode, commitObj, callback);\r\n    };\r\n\r\n    return <%= addOnId %>;\r\n});"
}});